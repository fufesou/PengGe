\hypertarget{msgwrap_8h}{}\section{D\+:/project/\+Peng\+Ge/client\+\_\+server/src/common/msgwrap.h File Reference}
\label{msgwrap_8h}\index{D\+:/project/\+Peng\+Ge/client\+\_\+server/src/common/msgwrap.\+h@{D\+:/project/\+Peng\+Ge/client\+\_\+server/src/common/msgwrap.\+h}}


This file describe the message header for sending and receiving.  


This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{msgwrap_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header}
\begin{DoxyCompactList}\small\item\em \hyperlink{structcsmsg__header}{csmsg\+\_\+header} describe the header in pool item. \hyperlink{structcsmsg__header}{csmsg\+\_\+header} is followed by the actual message data. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{msgwrap_8h_a992091194e59740446257e10c0d7864d}{csmsg\+\_\+copyaddr} (struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header} $\ast$msghdr, const struct sockaddr $\ast$addr, int addrlen)
\begin{DoxyCompactList}\small\item\em csmsg\+\_\+copyaddr This function set the value of address information. \end{DoxyCompactList}\item 
int \hyperlink{msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1}{csmsg\+\_\+merge} (const struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header} $\ast$msghdr, const char $\ast$data, char $\ast$unit, int unitlen)
\begin{DoxyCompactList}\small\item\em csmsg\+\_\+merge \end{DoxyCompactList}\item 
void \hyperlink{msgwrap_8h_a9c2497291895fc1a67c1fd399b499352}{csmsg\+\_\+extract} (const char $\ast$unit, const struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header} $\ast$$\ast$msgheader, const char $\ast$$\ast$data)
\begin{DoxyCompactList}\small\item\em csmsg\+\_\+extract \end{DoxyCompactList}\item 
int \hyperlink{msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7}{csmsg\+\_\+extract\+\_\+copy} (const char $\ast$unit, struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header} $\ast$msgheader, char $\ast$data, int datalen)
\begin{DoxyCompactList}\small\item\em csmsg\+\_\+extract\+\_\+copy \end{DoxyCompactList}\item 
int \hyperlink{msgwrap_8h_ad813358703a8d2859cc883e8ee15c286}{csmsg\+\_\+push2pool} (const char $\ast$data, const struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header} $\ast$msgheader, struct \hyperlink{structcsmsgpool}{csmsgpool} $\ast$pool)
\begin{DoxyCompactList}\small\item\em csmsg\+\_\+push2pool will firstly copy message data and the unit header to single char array. And then push the single char array to struct csmsgpool. The procedure can be splitted into three steps\+: \end{DoxyCompactList}\item 
int \hyperlink{msgwrap_8h_a116afb019547278f14bc11309ba7c387}{csmsg\+\_\+pull\+\_\+from\+\_\+pool} (char $\ast$data, int datalen, struct \hyperlink{structcsmsg__header}{csmsg\+\_\+header} $\ast$msgheader, struct \hyperlink{structcsmsgpool}{csmsgpool} $\ast$pool)
\begin{DoxyCompactList}\small\item\em csmsg\+\_\+pull\+\_\+from\+\_\+pool works the opposite as csmsg\+\_\+push2pool does. The procedure can be splitted into three steps\+: \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This file describe the message header for sending and receiving. 

\begin{DoxyAuthor}{Author}
cxl, \href{mailto:shuanglongchen@yeah.net}{\tt shuanglongchen@yeah.\+net} 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
0.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
2015-\/10-\/19 
\end{DoxyDate}
\begin{DoxyParagraph}{last modified}
周五 2015-\/11-\/06 12\+:02\+:41 中国标准时间 
\end{DoxyParagraph}


\subsection{Function Documentation}
\hypertarget{msgwrap_8h_a992091194e59740446257e10c0d7864d}{}\index{msgwrap.\+h@{msgwrap.\+h}!csmsg\+\_\+copyaddr@{csmsg\+\_\+copyaddr}}
\index{csmsg\+\_\+copyaddr@{csmsg\+\_\+copyaddr}!msgwrap.\+h@{msgwrap.\+h}}
\subsubsection[{csmsg\+\_\+copyaddr(struct csmsg\+\_\+header $\ast$msghdr, const struct sockaddr $\ast$addr, int addrlen)}]{\setlength{\rightskip}{0pt plus 5cm}int csmsg\+\_\+copyaddr (
\begin{DoxyParamCaption}
\item[{struct {\bf csmsg\+\_\+header} $\ast$}]{msghdr, }
\item[{const struct sockaddr $\ast$}]{addr, }
\item[{int}]{addrlen}
\end{DoxyParamCaption}
)}\label{msgwrap_8h_a992091194e59740446257e10c0d7864d}


csmsg\+\_\+copyaddr This function set the value of address information. 


\begin{DoxyParams}{Parameters}
{\em msghdr} & \\
\hline
{\em addr} & \\
\hline
{\em addrlen} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if succeed, 1 if fail. 
\end{DoxyReturn}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=277pt]{msgwrap_8h_a992091194e59740446257e10c0d7864d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{msgwrap_8h_a992091194e59740446257e10c0d7864d_icgraph}
\end{center}
\end{figure}


\hypertarget{msgwrap_8h_a9c2497291895fc1a67c1fd399b499352}{}\index{msgwrap.\+h@{msgwrap.\+h}!csmsg\+\_\+extract@{csmsg\+\_\+extract}}
\index{csmsg\+\_\+extract@{csmsg\+\_\+extract}!msgwrap.\+h@{msgwrap.\+h}}
\subsubsection[{csmsg\+\_\+extract(const char $\ast$unit, const struct csmsg\+\_\+header $\ast$$\ast$msgheader, const char $\ast$$\ast$data)}]{\setlength{\rightskip}{0pt plus 5cm}void csmsg\+\_\+extract (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{unit, }
\item[{const struct {\bf csmsg\+\_\+header} $\ast$$\ast$}]{msgheader, }
\item[{const char $\ast$$\ast$}]{data}
\end{DoxyParamCaption}
)}\label{msgwrap_8h_a9c2497291895fc1a67c1fd399b499352}


csmsg\+\_\+extract 


\begin{DoxyParams}{Parameters}
{\em unit} & \\
\hline
{\em msgheader} & \\
\hline
{\em data} & \\
\hline
\end{DoxyParams}
\hypertarget{msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7}{}\index{msgwrap.\+h@{msgwrap.\+h}!csmsg\+\_\+extract\+\_\+copy@{csmsg\+\_\+extract\+\_\+copy}}
\index{csmsg\+\_\+extract\+\_\+copy@{csmsg\+\_\+extract\+\_\+copy}!msgwrap.\+h@{msgwrap.\+h}}
\subsubsection[{csmsg\+\_\+extract\+\_\+copy(const char $\ast$unit, struct csmsg\+\_\+header $\ast$msgheader, char $\ast$data, int datalen)}]{\setlength{\rightskip}{0pt plus 5cm}int csmsg\+\_\+extract\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{unit, }
\item[{struct {\bf csmsg\+\_\+header} $\ast$}]{msgheader, }
\item[{char $\ast$}]{data, }
\item[{int}]{datalen}
\end{DoxyParamCaption}
)}\label{msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7}


csmsg\+\_\+extract\+\_\+copy 


\begin{DoxyParams}{Parameters}
{\em unit} & \\
\hline
{\em msgheader} & \\
\hline
{\em data} & \\
\hline
{\em datalen} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=293pt]{msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=336pt]{msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph}
\end{center}
\end{figure}


\hypertarget{msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1}{}\index{msgwrap.\+h@{msgwrap.\+h}!csmsg\+\_\+merge@{csmsg\+\_\+merge}}
\index{csmsg\+\_\+merge@{csmsg\+\_\+merge}!msgwrap.\+h@{msgwrap.\+h}}
\subsubsection[{csmsg\+\_\+merge(const struct csmsg\+\_\+header $\ast$msghdr, const char $\ast$data, char $\ast$unit, int unitlen)}]{\setlength{\rightskip}{0pt plus 5cm}int csmsg\+\_\+merge (
\begin{DoxyParamCaption}
\item[{const struct {\bf csmsg\+\_\+header} $\ast$}]{msghdr, }
\item[{const char $\ast$}]{data, }
\item[{char $\ast$}]{unit, }
\item[{int}]{unitlen}
\end{DoxyParamCaption}
)}\label{msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1}


csmsg\+\_\+merge 


\begin{DoxyParams}{Parameters}
{\em msgheader} & \\
\hline
{\em data} & \\
\hline
{\em unit} & \\
\hline
{\em unitlen} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if succeed, 1 if fail. 
\end{DoxyReturn}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=264pt]{msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_icgraph}
\end{center}
\end{figure}


\hypertarget{msgwrap_8h_a116afb019547278f14bc11309ba7c387}{}\index{msgwrap.\+h@{msgwrap.\+h}!csmsg\+\_\+pull\+\_\+from\+\_\+pool@{csmsg\+\_\+pull\+\_\+from\+\_\+pool}}
\index{csmsg\+\_\+pull\+\_\+from\+\_\+pool@{csmsg\+\_\+pull\+\_\+from\+\_\+pool}!msgwrap.\+h@{msgwrap.\+h}}
\subsubsection[{csmsg\+\_\+pull\+\_\+from\+\_\+pool(char $\ast$data, int datalen, struct csmsg\+\_\+header $\ast$msgheader, struct csmsgpool $\ast$pool)}]{\setlength{\rightskip}{0pt plus 5cm}int csmsg\+\_\+pull\+\_\+from\+\_\+pool (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{data, }
\item[{int}]{datalen, }
\item[{struct {\bf csmsg\+\_\+header} $\ast$}]{msgheader, }
\item[{struct {\bf csmsgpool} $\ast$}]{pool}
\end{DoxyParamCaption}
)}\label{msgwrap_8h_a116afb019547278f14bc11309ba7c387}


csmsg\+\_\+pull\+\_\+from\+\_\+pool works the opposite as csmsg\+\_\+push2pool does. The procedure can be splitted into three steps\+: 


\begin{DoxyEnumerate}
\item take out one item from filled buffer in pool.
\item copy data and msgheader from the item.
\item push the item into the empty buffer.
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em data} & the message data \\
\hline
{\em datalen} & the length of message data. \\
\hline
{\em msgheader} & the unit header struct. \\
\hline
{\em pool} & the pool to operate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success. There is a filled buffer for operation. 1 if fail. There is no filled buffer left.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{msgwrap_8h_ad813358703a8d2859cc883e8ee15c286}{csmsg\+\_\+push2pool} 
\end{DoxySeeAlso}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{msgwrap_8h_a116afb019547278f14bc11309ba7c387_cgraph}
\end{center}
\end{figure}


\hypertarget{msgwrap_8h_ad813358703a8d2859cc883e8ee15c286}{}\index{msgwrap.\+h@{msgwrap.\+h}!csmsg\+\_\+push2pool@{csmsg\+\_\+push2pool}}
\index{csmsg\+\_\+push2pool@{csmsg\+\_\+push2pool}!msgwrap.\+h@{msgwrap.\+h}}
\subsubsection[{csmsg\+\_\+push2pool(const char $\ast$data, const struct csmsg\+\_\+header $\ast$msgheader, struct csmsgpool $\ast$pool)}]{\setlength{\rightskip}{0pt plus 5cm}int csmsg\+\_\+push2pool (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{const struct {\bf csmsg\+\_\+header} $\ast$}]{msgheader, }
\item[{struct {\bf csmsgpool} $\ast$}]{pool}
\end{DoxyParamCaption}
)}\label{msgwrap_8h_ad813358703a8d2859cc883e8ee15c286}


csmsg\+\_\+push2pool will firstly copy message data and the unit header to single char array. And then push the single char array to struct csmsgpool. The procedure can be splitted into three steps\+: 


\begin{DoxyEnumerate}
\item take out one item from empty buffer in the pool.
\item copy data and msgheader to the item.
\item push the item into the filled buffer
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em data} & the message data. \\
\hline
{\em msgheader} & the unit header struct. \\
\hline
{\em pool} & the pool to operate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success. There is en empty buffer for operation. 1 if fail. There is no empty buffer left. 
\end{DoxyReturn}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{msgwrap_8h_ad813358703a8d2859cc883e8ee15c286_cgraph}
\end{center}
\end{figure}


