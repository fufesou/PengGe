<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cross-platform udp client-server: D:/project/PengGe/client_server/src/common/msgwrap.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cross-platform udp client-server
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A Simple client server solution with rtt guarantee.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fdedb0aba14d44ce9d99bc100e026e6a.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">msgwrap.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>length check is required for memcpy in this file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;semaphore.h&gt;</code><br />
<code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utility__wrap_8h_source.html">utility_wrap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sock__types_8h_source.html">sock_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lightthread_8h_source.html">lightthread.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bufarray_8h_source.html">bufarray.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="msgpool_8h_source.html">msgpool.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="msgwrap_8h_source.html">msgwrap.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for msgwrap.c:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c__incl.png" border="0" usemap="#_d_1_2project_2_peng_ge_2client__server_2src_2common_2msgwrap_8c" alt=""/></div>
<map name="_d_1_2project_2_peng_ge_2client__server_2src_2common_2msgwrap_8c" id="_d_1_2project_2_peng_ge_2client__server_2src_2common_2msgwrap_8c">
<area shape="rect" id="node9" href="macros_8h.html" title="This file define some basic macro operations and functions. And .. some macros stand for config data(..." alt="" coords="696,95,772,121"/>
<area shape="rect" id="node10" href="utility__wrap_8h.html" title="This function defines some utility wrap functions, such as memcpy. " alt="" coords="797,95,895,121"/>
<area shape="rect" id="node11" href="sock__types_8h.html" title="This file defines some basic socket types and macros for this application. " alt="" coords="920,95,1020,121"/>
<area shape="rect" id="node12" href="lightthread_8h.html" title="This file defines some basic wrapper functions of thread, mutex and semaphore. " alt="" coords="1045,95,1138,121"/>
<area shape="rect" id="node13" href="bufarray_8h.html" title="The basic buffer operations that implemented with circular queue. " alt="" coords="1163,95,1241,121"/>
<area shape="rect" id="node14" href="msgpool_8h.html" title="This file defines message buffer pool operations. With thread, mutex, semaphore used, This struct csmsgpool can be used for constructing multithread environment. " alt="" coords="1266,95,1349,121"/>
<area shape="rect" id="node15" href="msgwrap_8h.html" title="This file describe the message header for sending and receiving. " alt="" coords="1373,95,1458,121"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a992091194e59740446257e10c0d7864d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8c.html#a992091194e59740446257e10c0d7864d">csmsg_copyaddr</a> (struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msghdr, const struct sockaddr *addr, int addrlen)</td></tr>
<tr class="memdesc:a992091194e59740446257e10c0d7864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_copyaddr This function set the value of address information.  <a href="#a992091194e59740446257e10c0d7864d">More...</a><br /></td></tr>
<tr class="separator:a992091194e59740446257e10c0d7864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2e50286de90e21dec452fa67d9268"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8c.html#a4af2e50286de90e21dec452fa67d9268">csmsg_merge</a> (const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, const char *data, char *unit, int unitlen)</td></tr>
<tr class="memdesc:a4af2e50286de90e21dec452fa67d9268"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_merge  <a href="#a4af2e50286de90e21dec452fa67d9268">More...</a><br /></td></tr>
<tr class="separator:a4af2e50286de90e21dec452fa67d9268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2497291895fc1a67c1fd399b499352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8c.html#a9c2497291895fc1a67c1fd399b499352">csmsg_extract</a> (const char *unit, const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> **msgheader, const char **data)</td></tr>
<tr class="memdesc:a9c2497291895fc1a67c1fd399b499352"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_extract  <a href="#a9c2497291895fc1a67c1fd399b499352">More...</a><br /></td></tr>
<tr class="separator:a9c2497291895fc1a67c1fd399b499352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe79a0a1bb14bb4cf053f7bbadb78a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8c.html#adbe79a0a1bb14bb4cf053f7bbadb78a7">csmsg_extract_copy</a> (const char *unit, struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, char *data, int datalen)</td></tr>
<tr class="memdesc:adbe79a0a1bb14bb4cf053f7bbadb78a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_extract_copy  <a href="#adbe79a0a1bb14bb4cf053f7bbadb78a7">More...</a><br /></td></tr>
<tr class="separator:adbe79a0a1bb14bb4cf053f7bbadb78a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813358703a8d2859cc883e8ee15c286"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8c.html#ad813358703a8d2859cc883e8ee15c286">csmsg_push2pool</a> (const char *data, const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *pool)</td></tr>
<tr class="memdesc:ad813358703a8d2859cc883e8ee15c286"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_push2pool will firstly copy message data and the unit header to single char array. And then push the single char array to struct csmsgpool. The procedure can be splitted into three steps:  <a href="#ad813358703a8d2859cc883e8ee15c286">More...</a><br /></td></tr>
<tr class="separator:ad813358703a8d2859cc883e8ee15c286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116afb019547278f14bc11309ba7c387"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8c.html#a116afb019547278f14bc11309ba7c387">csmsg_pull_from_pool</a> (char *data, int datalen, struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *pool)</td></tr>
<tr class="memdesc:a116afb019547278f14bc11309ba7c387"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_pull_from_pool works the opposite as csmsg_push2pool does. The procedure can be splitted into three steps:  <a href="#a116afb019547278f14bc11309ba7c387">More...</a><br /></td></tr>
<tr class="separator:a116afb019547278f14bc11309ba7c387"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>length check is required for memcpy in this file. </p>
<dl class="section author"><dt>Author</dt><dd>cxl, <a href="#" onclick="location.href='mai'+'lto:'+'shu'+'an'+'glo'+'ng'+'che'+'n@'+'yea'+'h.'+'net'; return false;">shuan<span style="display: none;">.nosp@m.</span>glon<span style="display: none;">.nosp@m.</span>gchen<span style="display: none;">.nosp@m.</span>@yea<span style="display: none;">.nosp@m.</span>h.net</a> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015-10-19 </dd></dl>
<dl class="section user"><dt>last modified</dt><dd>周五 2015-11-06 12:04:44 中国标准时间 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a992091194e59740446257e10c0d7864d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_copyaddr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msghdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_copyaddr This function set the value of address information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msghdr</td><td></td></tr>
    <tr><td class="paramname">addr</td><td></td></tr>
    <tr><td class="paramname">addrlen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if succeed, 1 if fail. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_a992091194e59740446257e10c0d7864d_cgraph.png" border="0" usemap="#msgwrap_8c_a992091194e59740446257e10c0d7864d_cgraph" alt=""/></div>
<map name="msgwrap_8c_a992091194e59740446257e10c0d7864d_cgraph" id="msgwrap_8c_a992091194e59740446257e10c0d7864d_cgraph">
<area shape="rect" id="node2" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="175,5,268,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_a992091194e59740446257e10c0d7864d_icgraph.png" border="0" usemap="#msgwrap_8c_a992091194e59740446257e10c0d7864d_icgraph" alt=""/></div>
<map name="msgwrap_8c_a992091194e59740446257e10c0d7864d_icgraph" id="msgwrap_8c_a992091194e59740446257e10c0d7864d_icgraph">
<area shape="rect" id="node2" href="unix__client__sendrecv_8c.html#aeecc65b7dbf1e0ac8f806ba8f518dab9" title="csclient_sendrecv " alt="" coords="175,5,300,32"/>
<area shape="rect" id="node3" href="client__udp_8c.html#a571252c127c68c849fdf766d6cef63e2" title="csclient_udp_once This function process udp send&amp;recv one time. " alt="" coords="348,5,479,32"/>
<area shape="rect" id="node4" href="client__udp_8c.html#a8be5e8ba05fdac392536b4bb22d8914b" title="csclient_udp This function process udp communication with server. This function call csclient_udp_onc..." alt="" coords="527,5,621,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9c2497291895fc1a67c1fd399b499352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csmsg_extract </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> **&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_extract </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td></td></tr>
    <tr><td class="paramname">msgheader</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbe79a0a1bb14bb4cf053f7bbadb78a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_extract_copy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datalen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_extract_copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td></td></tr>
    <tr><td class="paramname">msgheader</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">datalen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph.png" border="0" usemap="#msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph" alt=""/></div>
<map name="msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph" id="msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph">
<area shape="rect" id="node2" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="196,5,289,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph.png" border="0" usemap="#msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph" alt=""/></div>
<map name="msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph" id="msgwrap_8c_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph">
<area shape="rect" id="node2" href="msgwrap_8h.html#a116afb019547278f14bc11309ba7c387" title="csmsg_pull_from_pool works the opposite as csmsg_push2pool does. The procedure can be splitted into t..." alt="" coords="196,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4af2e50286de90e21dec452fa67d9268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_merge </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msghdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_merge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgheader</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">unit</td><td></td></tr>
    <tr><td class="paramname">unitlen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if succeed, 1 if fail. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_cgraph.png" border="0" usemap="#msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_cgraph" alt=""/></div>
<map name="msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_cgraph" id="msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_cgraph">
<area shape="rect" id="node2" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="157,5,251,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_icgraph.png" border="0" usemap="#msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_icgraph" alt=""/></div>
<map name="msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_icgraph" id="msgwrap_8c_a4af2e50286de90e21dec452fa67d9268_icgraph">
<area shape="rect" id="node2" href="unix__client__sendrecv_8c.html#aeecc65b7dbf1e0ac8f806ba8f518dab9" title="csclient_sendrecv " alt="" coords="158,5,283,32"/>
<area shape="rect" id="node5" href="msgwrap_8h.html#ad813358703a8d2859cc883e8ee15c286" title="csmsg_push2pool will firstly copy message data and the unit header to single char array..." alt="" coords="157,56,284,83"/>
<area shape="rect" id="node3" href="client__udp_8c.html#a571252c127c68c849fdf766d6cef63e2" title="csclient_udp_once This function process udp send&amp;recv one time. " alt="" coords="332,5,463,32"/>
<area shape="rect" id="node4" href="client__udp_8c.html#a8be5e8ba05fdac392536b4bb22d8914b" title="csclient_udp This function process udp communication with server. This function call csclient_udp_onc..." alt="" coords="511,5,605,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a116afb019547278f14bc11309ba7c387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_pull_from_pool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_pull_from_pool works the opposite as csmsg_push2pool does. The procedure can be splitted into three steps: </p>
<ol type="1">
<li>take out one item from filled buffer in pool.</li>
<li>copy data and msgheader from the item.</li>
<li>push the item into the empty buffer.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the message data </td></tr>
    <tr><td class="paramname">datalen</td><td>the length of message data. </td></tr>
    <tr><td class="paramname">msgheader</td><td>the unit header struct. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. There is a filled buffer for operation. 1 if fail. There is no filled buffer left.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="msgwrap_8h.html#ad813358703a8d2859cc883e8ee15c286" title="csmsg_push2pool will firstly copy message data and the unit header to single char array...">csmsg_push2pool</a> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_a116afb019547278f14bc11309ba7c387_cgraph.png" border="0" usemap="#msgwrap_8c_a116afb019547278f14bc11309ba7c387_cgraph" alt=""/></div>
<map name="msgwrap_8c_a116afb019547278f14bc11309ba7c387_cgraph" id="msgwrap_8c_a116afb019547278f14bc11309ba7c387_cgraph">
<area shape="rect" id="node2" href="msgpool_8c.html#a14439a45efe508d7c98e10cef3737104" title="cspool_pullitem " alt="" coords="219,56,331,83"/>
<area shape="rect" id="node5" href="msgwrap_8c.html#adbe79a0a1bb14bb4cf053f7bbadb78a7" title="csmsg_extract_copy " alt="" coords="204,107,347,133"/>
<area shape="rect" id="node7" href="msgpool_8c.html#a83f09a2407be63d0ce25eb505f7a04c4" title="cspool_pushitem " alt="" coords="215,5,335,32"/>
<area shape="rect" id="node3" href="lightthread_8c.html#a78561b071805b213f88d0757b381aa92" title="csmutex_lock " alt="" coords="402,56,505,83"/>
<area shape="rect" id="node4" href="lightthread_8c.html#abe0d10d1918d0b3fc8a9966e9710b632" title="csmutex_unlock This function unlock the numtex. " alt="" coords="395,5,512,32"/>
<area shape="rect" id="node6" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="407,107,500,133"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad813358703a8d2859cc883e8ee15c286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_push2pool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_push2pool will firstly copy message data and the unit header to single char array. And then push the single char array to struct csmsgpool. The procedure can be splitted into three steps: </p>
<ol type="1">
<li>take out one item from empty buffer in the pool.</li>
<li>copy data and msgheader to the item.</li>
<li>push the item into the filled buffer</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the message data. </td></tr>
    <tr><td class="paramname">msgheader</td><td>the unit header struct. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. There is en empty buffer for operation. 1 if fail. There is no empty buffer left. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8c_ad813358703a8d2859cc883e8ee15c286_cgraph.png" border="0" usemap="#msgwrap_8c_ad813358703a8d2859cc883e8ee15c286_cgraph" alt=""/></div>
<map name="msgwrap_8c_ad813358703a8d2859cc883e8ee15c286_cgraph" id="msgwrap_8c_ad813358703a8d2859cc883e8ee15c286_cgraph">
<area shape="rect" id="node2" href="msgpool_8c.html#a14439a45efe508d7c98e10cef3737104" title="cspool_pullitem " alt="" coords="184,56,296,83"/>
<area shape="rect" id="node5" href="msgwrap_8c.html#a4af2e50286de90e21dec452fa67d9268" title="csmsg_merge " alt="" coords="188,107,292,133"/>
<area shape="rect" id="node7" href="msgpool_8c.html#a83f09a2407be63d0ce25eb505f7a04c4" title="cspool_pushitem " alt="" coords="180,5,300,32"/>
<area shape="rect" id="node3" href="lightthread_8c.html#a78561b071805b213f88d0757b381aa92" title="csmutex_lock " alt="" coords="355,56,458,83"/>
<area shape="rect" id="node4" href="lightthread_8c.html#abe0d10d1918d0b3fc8a9966e9710b632" title="csmutex_unlock This function unlock the numtex. " alt="" coords="348,5,465,32"/>
<area shape="rect" id="node6" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="360,107,453,133"/>
</map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
