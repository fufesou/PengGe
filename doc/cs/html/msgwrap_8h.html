<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cross-platform udp client-server: D:/project/PengGe/client_server/src/common/msgwrap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cross-platform udp client-server
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A Simple client server solution with rtt guarantee.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fdedb0aba14d44ce9d99bc100e026e6a.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">msgwrap.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file describe the message header for sending and receiving.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h__dep__incl.png" border="0" usemap="#_d_1_2project_2_peng_ge_2client__server_2src_2common_2msgwrap_8hdep" alt=""/></div>
<map name="_d_1_2project_2_peng_ge_2client__server_2src_2common_2msgwrap_8hdep" id="_d_1_2project_2_peng_ge_2client__server_2src_2common_2msgwrap_8hdep">
<area shape="rect" id="node2" href="client__msgdispatch_8c.html" title="D:/project/PengGe/client\l_server/src/client/client\l_msgdispatch.c" alt="" coords="5,95,169,151"/>
<area shape="rect" id="node3" href="client__udp_8c.html" title="This file prcess client udp message sendrecv. For now a lot config data is hard coded, reimplementation must be done when config parser complete. " alt="" coords="194,102,389,143"/>
<area shape="rect" id="node4" href="unix__client__sendrecv_8c.html" title="This file provide the linux version of client sendrecv. " alt="" coords="413,95,577,151"/>
<area shape="rect" id="node5" href="msgpool__dispatch_8c.html" title="D:/project/PengGe/client\l_server/src/common/msgpool\l_dispatch.c" alt="" coords="602,95,794,151"/>
<area shape="rect" id="node6" href="msgwrap_8c.html" title="length check is required for memcpy in this file. " alt="" coords="819,102,1025,143"/>
<area shape="rect" id="node7" href="server_8c.html" title="The functions prefexed with &quot;s_&quot; are static functions. " alt="" coords="1049,102,1221,143"/>
<area shape="rect" id="node8" href="server__msgdispatch_8c.html" title="D:/project/PengGe/client\l_server/src/server/server\l_msgdispatch.c" alt="" coords="1245,95,1409,151"/>
</map>
</div>
</div>
<p><a href="msgwrap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsmsg__header.html">csmsg_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcsmsg__header.html" title="csmsg_header describe the header in pool item. csmsg_header is followed by the actual message data...">csmsg_header</a> describe the header in pool item. <a class="el" href="structcsmsg__header.html" title="csmsg_header describe the header in pool item. csmsg_header is followed by the actual message data...">csmsg_header</a> is followed by the actual message data.  <a href="structcsmsg__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a992091194e59740446257e10c0d7864d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8h.html#a992091194e59740446257e10c0d7864d">csmsg_copyaddr</a> (struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msghdr, const struct sockaddr *addr, int addrlen)</td></tr>
<tr class="memdesc:a992091194e59740446257e10c0d7864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_copyaddr This function set the value of address information.  <a href="#a992091194e59740446257e10c0d7864d">More...</a><br /></td></tr>
<tr class="separator:a992091194e59740446257e10c0d7864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a90c5800135ab934256e8d2135b3cb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8h.html#a7a90c5800135ab934256e8d2135b3cb1">csmsg_merge</a> (const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msghdr, const char *data, char *unit, int unitlen)</td></tr>
<tr class="memdesc:a7a90c5800135ab934256e8d2135b3cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_merge  <a href="#a7a90c5800135ab934256e8d2135b3cb1">More...</a><br /></td></tr>
<tr class="separator:a7a90c5800135ab934256e8d2135b3cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2497291895fc1a67c1fd399b499352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8h.html#a9c2497291895fc1a67c1fd399b499352">csmsg_extract</a> (const char *unit, const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> **msgheader, const char **data)</td></tr>
<tr class="memdesc:a9c2497291895fc1a67c1fd399b499352"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_extract  <a href="#a9c2497291895fc1a67c1fd399b499352">More...</a><br /></td></tr>
<tr class="separator:a9c2497291895fc1a67c1fd399b499352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe79a0a1bb14bb4cf053f7bbadb78a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8h.html#adbe79a0a1bb14bb4cf053f7bbadb78a7">csmsg_extract_copy</a> (const char *unit, struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, char *data, int datalen)</td></tr>
<tr class="memdesc:adbe79a0a1bb14bb4cf053f7bbadb78a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_extract_copy  <a href="#adbe79a0a1bb14bb4cf053f7bbadb78a7">More...</a><br /></td></tr>
<tr class="separator:adbe79a0a1bb14bb4cf053f7bbadb78a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813358703a8d2859cc883e8ee15c286"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8h.html#ad813358703a8d2859cc883e8ee15c286">csmsg_push2pool</a> (const char *data, const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *pool)</td></tr>
<tr class="memdesc:ad813358703a8d2859cc883e8ee15c286"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_push2pool will firstly copy message data and the unit header to single char array. And then push the single char array to struct csmsgpool. The procedure can be splitted into three steps:  <a href="#ad813358703a8d2859cc883e8ee15c286">More...</a><br /></td></tr>
<tr class="separator:ad813358703a8d2859cc883e8ee15c286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116afb019547278f14bc11309ba7c387"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msgwrap_8h.html#a116afb019547278f14bc11309ba7c387">csmsg_pull_from_pool</a> (char *data, int datalen, struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *msgheader, struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *pool)</td></tr>
<tr class="memdesc:a116afb019547278f14bc11309ba7c387"><td class="mdescLeft">&#160;</td><td class="mdescRight">csmsg_pull_from_pool works the opposite as csmsg_push2pool does. The procedure can be splitted into three steps:  <a href="#a116afb019547278f14bc11309ba7c387">More...</a><br /></td></tr>
<tr class="separator:a116afb019547278f14bc11309ba7c387"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file describe the message header for sending and receiving. </p>
<dl class="section author"><dt>Author</dt><dd>cxl, <a href="#" onclick="location.href='mai'+'lto:'+'shu'+'an'+'glo'+'ng'+'che'+'n@'+'yea'+'h.'+'net'; return false;">shuan<span style="display: none;">.nosp@m.</span>glon<span style="display: none;">.nosp@m.</span>gchen<span style="display: none;">.nosp@m.</span>@yea<span style="display: none;">.nosp@m.</span>h.net</a> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015-10-19 </dd></dl>
<dl class="section user"><dt>last modified</dt><dd>周五 2015-11-06 12:02:41 中国标准时间 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a992091194e59740446257e10c0d7864d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_copyaddr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msghdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_copyaddr This function set the value of address information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msghdr</td><td></td></tr>
    <tr><td class="paramname">addr</td><td></td></tr>
    <tr><td class="paramname">addrlen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if succeed, 1 if fail. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_a992091194e59740446257e10c0d7864d_cgraph.png" border="0" usemap="#msgwrap_8h_a992091194e59740446257e10c0d7864d_cgraph" alt=""/></div>
<map name="msgwrap_8h_a992091194e59740446257e10c0d7864d_cgraph" id="msgwrap_8h_a992091194e59740446257e10c0d7864d_cgraph">
<area shape="rect" id="node2" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="175,5,268,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_a992091194e59740446257e10c0d7864d_icgraph.png" border="0" usemap="#msgwrap_8h_a992091194e59740446257e10c0d7864d_icgraph" alt=""/></div>
<map name="msgwrap_8h_a992091194e59740446257e10c0d7864d_icgraph" id="msgwrap_8h_a992091194e59740446257e10c0d7864d_icgraph">
<area shape="rect" id="node2" href="unix__client__sendrecv_8c.html#aeecc65b7dbf1e0ac8f806ba8f518dab9" title="csclient_sendrecv " alt="" coords="175,5,300,32"/>
<area shape="rect" id="node3" href="client__udp_8c.html#a571252c127c68c849fdf766d6cef63e2" title="csclient_udp_once This function process udp send&amp;recv one time. " alt="" coords="348,5,479,32"/>
<area shape="rect" id="node4" href="client__udp_8c.html#a8be5e8ba05fdac392536b4bb22d8914b" title="csclient_udp This function process udp communication with server. This function call csclient_udp_onc..." alt="" coords="527,5,621,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9c2497291895fc1a67c1fd399b499352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csmsg_extract </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> **&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_extract </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td></td></tr>
    <tr><td class="paramname">msgheader</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbe79a0a1bb14bb4cf053f7bbadb78a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_extract_copy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datalen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_extract_copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unit</td><td></td></tr>
    <tr><td class="paramname">msgheader</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">datalen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph.png" border="0" usemap="#msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph" alt=""/></div>
<map name="msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph" id="msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_cgraph">
<area shape="rect" id="node2" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="196,5,289,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph.png" border="0" usemap="#msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph" alt=""/></div>
<map name="msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph" id="msgwrap_8h_adbe79a0a1bb14bb4cf053f7bbadb78a7_icgraph">
<area shape="rect" id="node2" href="msgwrap_8h.html#a116afb019547278f14bc11309ba7c387" title="csmsg_pull_from_pool works the opposite as csmsg_push2pool does. The procedure can be splitted into t..." alt="" coords="196,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7a90c5800135ab934256e8d2135b3cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_merge </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msghdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_merge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgheader</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">unit</td><td></td></tr>
    <tr><td class="paramname">unitlen</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if succeed, 1 if fail. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_cgraph.png" border="0" usemap="#msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_cgraph" alt=""/></div>
<map name="msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_cgraph" id="msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_cgraph">
<area shape="rect" id="node2" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="157,5,251,32"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_icgraph.png" border="0" usemap="#msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_icgraph" alt=""/></div>
<map name="msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_icgraph" id="msgwrap_8h_a7a90c5800135ab934256e8d2135b3cb1_icgraph">
<area shape="rect" id="node2" href="unix__client__sendrecv_8c.html#aeecc65b7dbf1e0ac8f806ba8f518dab9" title="csclient_sendrecv " alt="" coords="158,5,283,32"/>
<area shape="rect" id="node5" href="msgwrap_8h.html#ad813358703a8d2859cc883e8ee15c286" title="csmsg_push2pool will firstly copy message data and the unit header to single char array..." alt="" coords="157,56,284,83"/>
<area shape="rect" id="node3" href="client__udp_8c.html#a571252c127c68c849fdf766d6cef63e2" title="csclient_udp_once This function process udp send&amp;recv one time. " alt="" coords="332,5,463,32"/>
<area shape="rect" id="node4" href="client__udp_8c.html#a8be5e8ba05fdac392536b4bb22d8914b" title="csclient_udp This function process udp communication with server. This function call csclient_udp_onc..." alt="" coords="511,5,605,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a116afb019547278f14bc11309ba7c387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_pull_from_pool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_pull_from_pool works the opposite as csmsg_push2pool does. The procedure can be splitted into three steps: </p>
<ol type="1">
<li>take out one item from filled buffer in pool.</li>
<li>copy data and msgheader from the item.</li>
<li>push the item into the empty buffer.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the message data </td></tr>
    <tr><td class="paramname">datalen</td><td>the length of message data. </td></tr>
    <tr><td class="paramname">msgheader</td><td>the unit header struct. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. There is a filled buffer for operation. 1 if fail. There is no filled buffer left.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="msgwrap_8h.html#ad813358703a8d2859cc883e8ee15c286" title="csmsg_push2pool will firstly copy message data and the unit header to single char array...">csmsg_push2pool</a> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_a116afb019547278f14bc11309ba7c387_cgraph.png" border="0" usemap="#msgwrap_8h_a116afb019547278f14bc11309ba7c387_cgraph" alt=""/></div>
<map name="msgwrap_8h_a116afb019547278f14bc11309ba7c387_cgraph" id="msgwrap_8h_a116afb019547278f14bc11309ba7c387_cgraph">
<area shape="rect" id="node2" href="msgpool_8c.html#a14439a45efe508d7c98e10cef3737104" title="cspool_pullitem " alt="" coords="219,56,331,83"/>
<area shape="rect" id="node5" href="msgwrap_8c.html#adbe79a0a1bb14bb4cf053f7bbadb78a7" title="csmsg_extract_copy " alt="" coords="204,107,347,133"/>
<area shape="rect" id="node7" href="msgpool_8c.html#a83f09a2407be63d0ce25eb505f7a04c4" title="cspool_pushitem " alt="" coords="215,5,335,32"/>
<area shape="rect" id="node3" href="lightthread_8c.html#a78561b071805b213f88d0757b381aa92" title="csmutex_lock " alt="" coords="402,56,505,83"/>
<area shape="rect" id="node4" href="lightthread_8c.html#abe0d10d1918d0b3fc8a9966e9710b632" title="csmutex_unlock This function unlock the numtex. " alt="" coords="395,5,512,32"/>
<area shape="rect" id="node6" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="407,107,500,133"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad813358703a8d2859cc883e8ee15c286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csmsg_push2pool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsmsg__header.html">csmsg_header</a> *&#160;</td>
          <td class="paramname"><em>msgheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsmsgpool.html">csmsgpool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>csmsg_push2pool will firstly copy message data and the unit header to single char array. And then push the single char array to struct csmsgpool. The procedure can be splitted into three steps: </p>
<ol type="1">
<li>take out one item from empty buffer in the pool.</li>
<li>copy data and msgheader to the item.</li>
<li>push the item into the filled buffer</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the message data. </td></tr>
    <tr><td class="paramname">msgheader</td><td>the unit header struct. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success. There is en empty buffer for operation. 1 if fail. There is no empty buffer left. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="msgwrap_8h_ad813358703a8d2859cc883e8ee15c286_cgraph.png" border="0" usemap="#msgwrap_8h_ad813358703a8d2859cc883e8ee15c286_cgraph" alt=""/></div>
<map name="msgwrap_8h_ad813358703a8d2859cc883e8ee15c286_cgraph" id="msgwrap_8h_ad813358703a8d2859cc883e8ee15c286_cgraph">
<area shape="rect" id="node2" href="msgpool_8c.html#a14439a45efe508d7c98e10cef3737104" title="cspool_pullitem " alt="" coords="184,56,296,83"/>
<area shape="rect" id="node5" href="msgwrap_8c.html#a4af2e50286de90e21dec452fa67d9268" title="csmsg_merge " alt="" coords="188,107,292,133"/>
<area shape="rect" id="node7" href="msgpool_8c.html#a83f09a2407be63d0ce25eb505f7a04c4" title="cspool_pushitem " alt="" coords="180,5,300,32"/>
<area shape="rect" id="node3" href="lightthread_8c.html#a78561b071805b213f88d0757b381aa92" title="csmutex_lock " alt="" coords="355,56,458,83"/>
<area shape="rect" id="node4" href="lightthread_8c.html#abe0d10d1918d0b3fc8a9966e9710b632" title="csmutex_unlock This function unlock the numtex. " alt="" coords="348,5,465,32"/>
<area shape="rect" id="node6" href="utility__wrap_8c.html#a897ef25d7e2a22733169e38eaf1c4294" title="cs_memecpy cs_memcpy is a simple wrapper of memcpy_s(windows) or memcpy(unix). " alt="" coords="360,107,453,133"/>
</map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
